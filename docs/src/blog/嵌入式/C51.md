# C51

::: details 其中涉及到的一些知识点

-   delay

    延时函数：51 单片机的时钟频率为 12 MHz,转换成 Hz 就是 $12×10^9$ Hz，也就是一个时钟周期可以执行 $12×10^9$ 次指令，那么一次指令的耗时就是
    $$ {1 \over 12×10^9} (s) $$
    而我们使用 `delay(50000)` ，花费的时间就是
    $$ {50000 \over 12×10^9} (s) $$
    大概就是 4.17 毫秒（ms）

:::

## 点灯

### 闪烁

```c
#include <reg52.h>

// 用sbit来定义一个I/O口
// 至于为什么是P0^0，因为这个是固定的，不同的单片机是不同的，要看单片机文档
sbit LED = P0 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{

    while (1) {
        // 将P0.0口赋值 0，该口电平为低，使LED亮
        // 如果想赋值 1为亮，则根据半导体性质，将LED灯反过来接即可
        // 下面代码每隔一段时间调整LED口的电压，实现闪烁功能
        LED = 0;
        delay(50000);
        LED = 1;
        delay(50000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281605109.webp" />

### 流水灯

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    int i;
    while (1)
    {
        for (i = 0; i < 8; i++) {
            /**
            * 我们有8个LED灯，每次让一个LED灯亮,就是让改口的电压为0
            * 数字 1 的二进制为 00000001，对他取反就是 11111110,很轻松
            * 实现了一个灯的亮，1 左移1位的二进制是 00000010，取反就是
            * 11111101 实现了第二个的灯亮，以此类推实现流水灯
            */
            P0 = ~(1 << i);
            delay(5000);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281610000.webp" />

## 蜂鸣器

::: details 蜂鸣器的一些知识点

-   有源蜂鸣器只需要给他通电就可以发出声音，无源蜂鸣器需要输入对应的脉冲信号才能发出声音

-   单片机提供的电流很小，可能不能使蜂鸣器正常工作，所以需要三极管允许更大的电流通过，使的蜂鸣器正常工作

:::

### 按键控制蜂鸣器

```c
#include <reg52.h>

sbit BUZZER = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                BUZZER = ~BUZZER; // [!code focus]
            }
        }
    }
}
```

选择有源蜂鸣器，将蜂鸣器的电压调整为 2V，打开电脑的声音，应该能听到蜂鸣器发出的声音

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291842526.webp" />

### 蜂鸣器播放音乐(生日快乐)

```c
#include <reg52.h>

sbit BEEP = P0 ^ 0;

unsigned char code SONG_TONE[] = {212, 212, 190, 212, 159, 169, 212, 212, 190, 212, 142, 159, 212, 212, 106, 126, 129, 169, 190, 119, 119, 126, 159, 142, 159, 0};
unsigned char code SONG_LONG[] = {9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 12, 12, 9, 3, 12, 12, 12, 24, 0};

void delay(unsigned int t)
{
    while (t--);
}

void PlayMusic()
{
    unsigned int i = 0, j, k;
    while (SONG_LONG[i] != 0 || SONG_TONE[i] != 0) {
        for (j = 0; j < SONG_LONG[i] * 30; j++) {
            BEEP = ~BEEP;
            for (k = 0; k < SONG_TONE[i] / 3; k++);
        }
        delay(100);
        i++;
    }
}

void main()
{
    while (1) {
        PlayMusic();
        delay(5000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291908604.webp" />

## 数码管

### 展示数字

我们选择的是共阳极数码管

```c
#include <reg52.h>

void main(void)
{
    while (1) {
        P0 = 0xC0;
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281641176.webp" />

更具需要选择对应的值来展示不同的数字

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281637979.webp" />

### 数字滚动

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    while (1) {
        for (i = 0; i < 10; i++) {
            P0 = seg[i];
            delay(50000);
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281652175.webp" />

### 动态扫描

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    int num;
    while (1) {
        num++;
        for (i = 0; i < 4; i++) {
            P2 = 1 << i;
            if (i == 0) {
                P0 = seg[num / 1000];
            } else if (i == 1) {
                P0 = seg[num % 1000 / 100];
            } else if (i == 2) {
                P0 = seg[num % 100 / 10];
            } else if (i == 3) {
                P0 = seg[num % 10];
            }
            /**
            * 刷新率在50Hz以上，人眼差不多就无法分辨出来了，所以延迟要
            * 少于某个阈值即可实现，500并非固定
            */
            delay(500);
            P0 = 0xff; // 消除拖影
        }
        if (num >= 9999) {
            num = 0;
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281955072.webp" />

## 点阵

### 心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291026672.webp" />

### 跳动的心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
        P2 = 0x00;
        P0 = 0x00;
        delay(60000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291024826.webp" />

## 按键

::: details 按键的一些知识点

-   消抖

    独立按键为机械弹性开关，当按键的触点闭合，断开时，由于弹性作用，独立按键没有办法立刻保持稳定，
    需要等待一定时间才能保持稳定，一般来说，这个抖动在 10 ~ 20ms 左右。

:::

### 按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        // 独立按键默认是高电平，即没有按下去为高电平，按下去为低电平。
        if (KEY == 0) { // 检测低电平，也就是按键是否按下
            delay(20);  // 消抖延时
            if (KEY == 0) {
                LED = ~LED;
                while (!LED); // 防误触，按下了长时间未松开则不处理（可以不写）
            }
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

### 按键实现数码管计数

```c
#include <reg52.h>

sbit KEY = P3 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                if (num >= 99) {
                    num = 0;
                } else
                    num++;
                while (!KEY) {
                    showSEG(num);
                }
            }
        }
        showSEG(num);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291152101.webp" />

### 矩阵键盘

```c
#include <reg52.h>

sbit L0 = P1 ^ 0;
sbit L1 = P1 ^ 1;
sbit L2 = P1 ^ 2;
sbit L3 = P1 ^ 3;

void delay(unsigned int t)
{
    while (t--);
}

int seg[16] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e};
int btn[4]  = {0xef, 0xdf, 0xbf, 0x7f};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    int i, j;
    while (1) {
        for (i = 0; i < 4; i++) {
            P1 = btn[i];
            for (j = 0; j < 4; j++) {
                if (L0 == 0) num = i * 4 + 1;
                if (L1 == 0) num = i * 4 + 2;
                if (L2 == 0) num = i * 4 + 3;
                if (L3 == 0) num = i * 4 + 4;
            }
            showSEG(num);
            delay(500);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291624029.webp" />

## 中断

::: details 中断的一些知识点

-   `EA` 中断总开关

    1: CPU 开放中断

    0: CPU 屏蔽所有中断申请

-   `EX0` (此处为外部中断 0，还有其余的中断例如 `EX1`, `ET0`, `ET1`, `ES`) (`ET0`/`ET1`): 定时器中断 (`ES`): 串口中断

    1: 允许外部中断 0 中断

    0: 禁止外部中断 0 中断

-   `IT0` 外部中断 0 触发方式选择位

    1: 下降沿触发

    0: 低电平触发

-   `interrupt 0`

    这里不是 C 基础语法，属于嵌入式的语法，用于处理中断 0，当中断 0 触发时，执行的函数

所以触发中断只需给对应的寄存器赋值，例如

```c
EA = 1;
EX0 = 1;
IT0 = 1;
```

执行完成后，会触发 `interrupt 0` 声明的函数，即 `abc`

```c
void abc() interrupt 0 {

}
```

:::

### 中断实现按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P3 ^ 2;

void it0_init()
{
    EA  = 1; // 总中断开
    EX0 = 1; // IT0中断开
    IT0 = 1; // TCON中控制INT0触发方式位，INT0下降沿触发中断
}

void it0_isr() interrupt 0
{
    if (KEY == 0) LED = !LED;
}

void main(void)
{
    it0_init(); // 中断初始化
    while (1);
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

## 火灾报警器(对温度、光亮等敏感)

## LCD 显示屏

## OLED 显示屏

## DS1302 时钟

## SG90 舵机

## 直流电机
