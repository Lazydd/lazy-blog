# C51

::: details 其中涉及到的一些知识点

-   delay

    延时函数：51 单片机的时钟频率为 12 MHz,转换成 Hz 就是 $12×10^6$ Hz，也就是一个时钟周期可以执行 $12×10^6$ 次指令，那么一次指令的耗时就是
    $$ {1 \over 12×10^6} (s) $$
    而我们使用 `delay(50000)` ，花费的时间就是
    $$ {600000 \over 12×10^6} (s) $$
    大概就是 `50` 毫秒（ms）

    `600000` 怎么来的

    `while(t--)` 循环需要 3 条指令: 加载 `t` 值、减 `1`、判断循环条件
    因此 `while(t--)` 需要 `12` 个时钟周期 (`3` 个指令 x `4` 个时钟周期)
    `delay(50000)` 中的循环需要执行 50000 次
    所以总的时钟周期数 = `50000 x 12 = 600000`

:::

## 点灯

### 闪烁

```c
#include <reg52.h>

// 用sbit来定义一个I/O口
// 至于为什么是P0^0，因为这个是固定的，不同的单片机是不同的，要看单片机文档
sbit LED = P0 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{

    while (1) {
        // 将P0.0口赋值 0，该口电平为低，使LED亮
        // 如果想赋值 1为亮，则根据半导体性质，将LED灯反过来接即可
        // 下面代码每隔一段时间调整LED口的电压，实现闪烁功能
        LED = 0;
        delay(50000);
        LED = 1;
        delay(50000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281605109.webp" />

### 流水灯

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    int i;
    while (1)
    {
        for (i = 0; i < 8; i++) {
            /**
            * 我们有8个LED灯，每次让一个LED灯亮,就是让改口的电压为0
            * 数字 1 的二进制为 00000001，对他取反就是 11111110,很轻松
            * 实现了一个灯的亮，1 左移1位的二进制是 00000010，取反就是
            * 11111101 实现了第二个的灯亮，以此类推实现流水灯
            */
            P0 = ~(1 << i);
            delay(5000);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281610000.webp" />

## 蜂鸣器

::: details 蜂鸣器的一些知识点

-   有源蜂鸣器只需要给他通电就可以发出声音，无源蜂鸣器需要输入对应的脉冲信号才能发出声音

-   单片机提供的电流很小，可能不能使蜂鸣器正常工作，所以需要三极管允许更大的电流通过，使的蜂鸣器正常工作

:::

### 按键控制蜂鸣器

```c
#include <reg52.h>

sbit BUZZER = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                BUZZER = ~BUZZER; // [!code focus]
            }
        }
    }
}
```

选择有源蜂鸣器，将蜂鸣器的电压调整为 2V，打开电脑的声音，应该能听到蜂鸣器发出的声音

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291842526.webp" />

### 蜂鸣器播放音乐(生日快乐)

```c
#include <reg52.h>

sbit BEEP = P0 ^ 0;

unsigned char code SONG_TONE[] = {212, 212, 190, 212, 159, 169, 212, 212, 190, 212, 142, 159, 212, 212, 106, 126, 129, 169, 190, 119, 119, 126, 159, 142, 159, 0};
unsigned char code SONG_LONG[] = {9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 12, 12, 9, 3, 12, 12, 12, 24, 0};

void delay(unsigned int t)
{
    while (t--);
}

void PlayMusic()
{
    unsigned int i = 0, j, k;
    while (SONG_LONG[i] != 0 || SONG_TONE[i] != 0) {
        for (j = 0; j < SONG_LONG[i] * 30; j++) {
            BEEP = ~BEEP;
            for (k = 0; k < SONG_TONE[i] / 3; k++);
        }
        delay(100);
        i++;
    }
}

void main()
{
    while (1) {
        PlayMusic();
        delay(5000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291908604.webp" />

## 数码管

### 展示数字

我们选择的是共阳极数码管

```c
#include <reg52.h>

void main(void)
{
    while (1) {
        P0 = 0xC0;
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281641176.webp" />

根据需要选择对应的值来展示不同的数字

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281637979.webp" />

### 数字滚动

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    while (1) {
        for (i = 0; i < 10; i++) {
            P0 = seg[i];
            delay(50000);
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281652175.webp" />

### 动态扫描

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    int num;
    while (1) {
        num++;
        for (i = 0; i < 4; i++) {
            P2 = 1 << i;
            if (i == 0) {
                P0 = seg[num / 1000];
            } else if (i == 1) {
                P0 = seg[num % 1000 / 100];
            } else if (i == 2) {
                P0 = seg[num % 100 / 10];
            } else if (i == 3) {
                P0 = seg[num % 10];
            }
            /**
            * 刷新率在50Hz以上，人眼差不多就无法分辨出来了，所以延迟要
            * 少于某个阈值即可实现，500并非固定
            */
            delay(500);
            P0 = 0xff; // 消除拖影
        }
        if (num >= 9999) {
            num = 0;
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281955072.webp" />

## 点阵

### 心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291026672.webp" />

### 跳动的心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
        P2 = 0x00;
        P0 = 0x00;
        delay(60000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291024826.webp" />

## 按键

::: details 按键的一些知识点

-   消抖

    独立按键为机械弹性开关，当按键的触点闭合，断开时，由于弹性作用，独立按键没有办法立刻保持稳定，
    需要等待一定时间才能保持稳定，一般来说，这个抖动在 10 ~ 20ms 左右。

:::

### 按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        // 独立按键默认是高电平，即没有按下去为高电平，按下去为低电平。
        if (KEY == 0) { // 检测低电平，也就是按键是否按下
            delay(20);  // 消抖延时
            if (KEY == 0) {
                LED = ~LED;
                while (!LED); // 防误触，按下了长时间未松开则不处理（可以不写）
            }
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

### 按键实现数码管计数

```c
#include <reg52.h>

sbit KEY = P3 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                if (num >= 99) {
                    num = 0;
                } else
                    num++;
                while (!KEY) {
                    showSEG(num);
                }
            }
        }
        showSEG(num);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291152101.webp" />

### 矩阵键盘

```c
#include <reg52.h>

sbit L0 = P1 ^ 0;
sbit L1 = P1 ^ 1;
sbit L2 = P1 ^ 2;
sbit L3 = P1 ^ 3;

void delay(unsigned int t)
{
    while (t--);
}

int seg[16] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e};
int btn[4]  = {0xef, 0xdf, 0xbf, 0x7f};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    int i, j;
    while (1) {
        for (i = 0; i < 4; i++) {
            P1 = btn[i];
            for (j = 0; j < 4; j++) {
                if (L0 == 0) num = i * 4 + 1;
                if (L1 == 0) num = i * 4 + 2;
                if (L2 == 0) num = i * 4 + 3;
                if (L3 == 0) num = i * 4 + 4;
            }
            showSEG(num);
            delay(500);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291624029.webp" />

## 中断

::: details 中断的一些知识点

| 符号 | 描述                      | 说明                                                         | 具体描述         |
| ---- | ------------------------- | ------------------------------------------------------------ | ---------------- |
| EA   | 中断总开关                | 为 `1` 时 CPU `开放` 中断，为 `0` 时 CPU `屏蔽` 所有中断申请 |
| EX0  | 外部中断                  | 为 `1` 时 `允许` 外部中断，为 `0` 时 `禁止` 外部中断         | 见下方 **`EX0`** |
| IT0  | 外部中断 0 触发方式选择位 | 为 `1` 时下降沿触发，为 `0` 时低电平触发                     |

**`EX0`**

-   (此处为外部中断 0，还有其余的中断例如 `EX1`, `ET0`, `ET1`, `ES`) (`ET0`/`ET1`): 定时器中断 (`ES`): 串口中断

**`interrupt 0`**

-   这里不是 C 基础语法，属于嵌入式的语法，用于处理中断 0，当中断 0 触发时，执行的函数

所以触发中断只需给对应的寄存器赋值，例如

```c
EA = 1;
EX0 = 1;
IT0 = 1;
```

执行完成后，会触发 `interrupt 0` 声明的函数，即 `abc`

```c
void abc() interrupt 0 {

}
```

:::

### 中断实现按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P3 ^ 2;

void it0_init()
{
    EA  = 1; // 总中断开
    EX0 = 1; // IT0中断开
    IT0 = 1; // TCON中控制INT0触发方式位，INT0下降沿触发中断
}

void it0_isr() interrupt 0
{
    if (KEY == 0) LED = !LED;
}

void main(void)
{
    it0_init(); // 中断初始化
    while (1);
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

## 火灾报警器(对温度、光亮等敏感)

## LCD 显示屏

::: details 其中涉及到的一些知识点

[更多信息](https://blog.csdn.net/m0_73964304/article/details/132531136)

| 符号    | 描述             | 说明                                     | 具体描述          |
| ------- | ---------------- | ---------------------------------------- | ----------------- |
| VSS     | 电源地           | 接地                                     |
| VDD     | 电源正极         | 接电源正极                               |
| VEE/VL  | 液晶显示偏压信号 | 接地，也可以接一个滑动变阻器来控制亮度   |
| RS      | 数据/命令选择    | 为 `1` 时传 `数据`，为 `0` 时传 `命令`   | 见下方 **`RS`**   |
| RW      | 读/写选择        | 为 `1` 时 `读`，为 `0` 时 `写`           |
| E       | 使能信号         | 为 `0` 时 显示屏工作，为 `1` 时 停止工作 |
| D0 ~ D7 | 数据             | 显示的字符                               | 见下方 **`编码`** |

**`RS`**

-   `RS` 信号决定了当前的操作是 `数据` 传送还是 `命令` 传送，其中传 `数据` 是指显示屏上显示什么字符，传 `命令` 是指在哪显示。

**`编码`**

-   显示字符时，需要将字符转换为对应的二进制数，然后通过 `D0` 到 `D7` 输出。字模编码见下图，低四位为横坐标，高四位为纵坐标。

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031132805.webp" />

**`指令表`**

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031351225.webp" />

:::

:::tip 注意
下面的代码中我们的数据 `Data` 首末尾都有三个空字符，所以在 `LCD_Write_Cmd` 写入 `0x00` 如果去除掉 `Data` 的空格，那么更改为 `0x03` 即可.

为什么要加 `0x80` ?

-   在指令集中，所有的指令都有一位是 `1`，`LCD1602` 就是用他来区分是哪一条指令的，其中 指令 8 就是第七位为 `1`，所以加上 `0x80` 就是在屏幕
    第一行第一个位置显示字符以此类推，即可控制在哪显示。

```c
void main()
{
    unsigned char code Data[] = "   I Love You   "; // "I Love You   "  // [!code focus]

    unsigned char i;

    LCD_Init();

    LCD_Write_Cmd(0x00 + 0x80); // LCD_Write_Cmd(0x03 + 0x80) // [!code focus]
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data[i]);
    }
    while (1);
}
```

:::

### 显示字符

```c
#include <reg52.h>

#define LCD_Data P0

sbit LCD_RS = P2 ^ 0;
sbit LCD_RW = P2 ^ 1;
sbit LCD_E  = P2 ^ 2;

void delay(unsigned int t)
{
    while (t--);
}

void main()
{
    unsigned char code Data[] = "   I Love You   "; // 第一行显示，共十六个字符

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data[i]);
    }
    while (1);
}
```

```c
// 初始化
void LCD_Init()
{
    LCD_Write_Cmd(0x01); // 指令1 ——清屏
    LCD_Write_Cmd(0x06); // 指令3 ——AC加1，画面不动
    LCD_Write_Cmd(0x0c); // 指令4 ——显示开，光标关，闪烁关
    LCD_Write_Cmd(0x38); // 指令6 ——8位数据接口，两行显示，5X7点阵
    LCD_Write_Cmd(0x80); // 指令8 ——从第一行第一列开始显示
}
```

```c
// 写命令
void LCD_Write_Cmd(unsigned char Cmd)
{

    LCD_Check_Busy(); // 判忙

    LCD_RS = 0; // 0 指令
    LCD_RW = 0; // 0 写

    LCD_E    = 0;
    LCD_Data = Cmd; // 送指令
    delay(2000);

    LCD_E = 1; // 拉高
    delay(5000);

    LCD_E = 0;
}
```

```c
// 写数据
void LCD_Write_Data(unsigned char Data)
{

    LCD_Check_Busy(); // 判忙

    LCD_RS = 1; // 1 数据
    LCD_RW = 0; // 0 写

    LCD_E    = 0;
    LCD_Data = Data; // 送数据
    delay(2000);

    LCD_E = 1; // 拉高
    delay(7000);

    LCD_E = 0;
}
```

```c
// 忙检测
void LCD_Check_Busy()
{

    unsigned char temp;

    LCD_Data = 0xff; // 十六进制：1111 1111
    LCD_RS   = 0;    // 0 指令
    LCD_RW   = 1;    // 1 读

    do {
        LCD_E = 1;        // 拉高
        temp  = LCD_Data; // 将 LCD 状态保存在 temp 中，用于判忙
        LCD_E = 0;        // 负跳变使能
    } while (temp & 0x80); // 结果为 1，LCD 忙，继续循环；结果为 0，LCD 不忙，可以进行后面的操作
}
```

因为使用的是 `P0` 口，所以需要右下角的上拉电阻，如果使用别的口，则不需要。

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031209760.webp" />

### 显示两行字符

```c
void main()
{
    unsigned char code Data_1[] = "   I Love You   "; // 第一行显示
    unsigned char code Data_2[] = "abcdefghABCDEFGH"; // 第二行显示

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data_1[i]);
    }

    LCD_Write_Cmd(0x40 + 0x80); // 第二行第一列地址
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data_2[i]);
    }

    while (1);
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031230726.png" />

### 画面移动

```c
void main()
{
    unsigned char code Data[] = "abcdefghigklmnopqrstuvwxyz";

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 26; i++) {
        LCD_Write_Data(Data[i]);
    }

    while (1) {
        delay(500000);       // 控制移动速度
        LCD_Write_Cmd(0x18); // 指令5 ——画面左移一个字符位，光标不动
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031403470.webp" />

## OLED 显示屏

## DS1302 时钟

## SG90 舵机

## 直流电机
