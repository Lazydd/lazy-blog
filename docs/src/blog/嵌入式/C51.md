# C51

::: details 其中涉及到的一些知识点

-   delay

    延时函数：51 单片机的时钟频率为 12 MHz,转换成 Hz 就是 $12×10^6$ Hz，也就是一个时钟周期可以执行 $12×10^6$ 次指令，那么一次指令的耗时就是
    $$ {1 \over 12×10^6} (s) $$
    而我们使用 `delay(50000)` ，花费的时间就是
    $$ {600000 \over 12×10^6} (s) $$
    大概就是 `50` 毫秒（ms）

    `600000` 怎么来的

    `while(t--)` 循环需要 3 条指令: 加载 `t` 值、减 `1`、判断循环条件
    因此 `while(t--)` 需要 `12` 个时钟周期 (`3` 个指令 x `4` 个时钟周期)
    `delay(50000)` 中的循环需要执行 50000 次
    所以总的时钟周期数 = `50000 x 12 = 600000`

:::

## 点灯

### 闪烁

```c
#include <reg52.h>

// 用sbit来定义一个I/O口
// 至于为什么是P0^0，因为这个是固定的，不同的单片机是不同的，要看单片机文档
sbit LED = P0 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{

    while (1) {
        // 将P0.0口赋值 0，该口电平为低，使LED亮
        // 如果想赋值 1为亮，则根据半导体性质，将LED灯反过来接即可
        // 下面代码每隔一段时间调整LED口的电压，实现闪烁功能
        LED = 0;
        delay(50000);
        LED = 1;
        delay(50000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281605109.webp" />

### 流水灯

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    int i;
    while (1)
    {
        for (i = 0; i < 8; i++) {
            /**
            * 我们有8个LED灯，每次让一个LED灯亮,就是让改口的电压为0
            * 数字 1 的二进制为 00000001，对他取反就是 11111110,很轻松
            * 实现了一个灯的亮，1 左移1位的二进制是 00000010，取反就是
            * 11111101 实现了第二个的灯亮，以此类推实现流水灯
            */
            P0 = ~(1 << i);
            delay(5000);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281610000.webp" />

## 蜂鸣器

::: details 蜂鸣器的一些知识点

-   有源蜂鸣器只需要给他通电就可以发出声音，无源蜂鸣器需要输入对应的脉冲信号才能发出声音

-   单片机提供的电流很小，可能不能使蜂鸣器正常工作，所以需要三极管允许更大的电流通过，使的蜂鸣器正常工作

:::

### 按键控制蜂鸣器

```c
#include <reg52.h>

sbit BUZZER = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                BUZZER = ~BUZZER; // [!code focus]
            }
        }
    }
}
```

选择有源蜂鸣器，将蜂鸣器的电压调整为 2V，打开电脑的声音，应该能听到蜂鸣器发出的声音

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291842526.webp" />

### 蜂鸣器播放音乐(生日快乐)

```c
#include <reg52.h>

sbit BEEP = P0 ^ 0;

unsigned char code SONG_TONE[] = {212, 212, 190, 212, 159, 169, 212, 212, 190, 212, 142, 159, 212, 212, 106, 126, 129, 169, 190, 119, 119, 126, 159, 142, 159, 0};
unsigned char code SONG_LONG[] = {9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 24, 9, 3, 12, 12, 12, 12, 12, 9, 3, 12, 12, 12, 24, 0};

void delay(unsigned int t)
{
    while (t--);
}

void PlayMusic()
{
    unsigned int i = 0, j, k;
    while (SONG_LONG[i] != 0 || SONG_TONE[i] != 0) {
        for (j = 0; j < SONG_LONG[i] * 30; j++) {
            BEEP = ~BEEP;
            for (k = 0; k < SONG_TONE[i] / 3; k++);
        }
        delay(100);
        i++;
    }
}

void main()
{
    while (1) {
        PlayMusic();
        delay(5000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291908604.webp" />

## 数码管

### 展示数字

我们选择的是共阳极数码管

```c
#include <reg52.h>

void main(void)
{
    while (1) {
        P0 = 0xC0;
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281641176.webp" />

根据需要选择对应的值来展示不同的数字

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281637979.webp" />

### 数字滚动

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    while (1) {
        for (i = 0; i < 10; i++) {
            P0 = seg[i];
            delay(50000);
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281652175.webp" />

### 动态扫描

```c
#include <reg52.h>

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
void main(void)
{
    int i;
    int num;
    while (1) {
        num++;
        for (i = 0; i < 4; i++) {
            P2 = 1 << i;
            if (i == 0) {
                P0 = seg[num / 1000];
            } else if (i == 1) {
                P0 = seg[num % 1000 / 100];
            } else if (i == 2) {
                P0 = seg[num % 100 / 10];
            } else if (i == 3) {
                P0 = seg[num % 10];
            }
            /**
            * 刷新率在50Hz以上，人眼差不多就无法分辨出来了，所以延迟要
            * 少于某个阈值即可实现，500并非固定
            */
            delay(500);
            P0 = 0xff; // 消除拖影
        }
        if (num >= 9999) {
            num = 0;
        }
    }
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411281955072.webp" />

## 点阵

### 心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291026672.webp" />

### 跳动的心

```c
#include <reg52.h>

unsigned char hang[8] = {0xFF, 0x99, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xE7};
unsigned char lie[8]  = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

void delay(unsigned int t)
{
    while (t--);
}
int main()
{
    while (1) {
        int i = 0;
        for (i = 0; i < 8; i++) {
            P2 = lie[i];
            P0 = hang[i];
            delay(300);
        }
        P2 = 0x00;
        P0 = 0x00;
        delay(60000);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291024826.webp" />

## 按键

::: details 按键的一些知识点

-   消抖

    独立按键为机械弹性开关，当按键的触点闭合，断开时，由于弹性作用，独立按键没有办法立刻保持稳定，
    需要等待一定时间才能保持稳定，一般来说，这个抖动在 10 ~ 20ms 左右。

:::

### 按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P2 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

void main(void)
{
    while (1) {
        // 独立按键默认是高电平，即没有按下去为高电平，按下去为低电平。
        if (KEY == 0) { // 检测低电平，也就是按键是否按下
            delay(20);  // 消抖延时
            if (KEY == 0) {
                LED = ~LED;
                while (!LED); // 防误触，按下了长时间未松开则不处理（可以不写）
            }
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

### 按键实现数码管计数

```c
#include <reg52.h>

sbit KEY = P3 ^ 0;

void delay(unsigned int t)
{
    while (t--);
}

int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    while (1) {
        if (KEY == 0) {
            delay(20);
            if (KEY == 0) {
                if (num >= 99) {
                    num = 0;
                } else
                    num++;
                while (!KEY) {
                    showSEG(num);
                }
            }
        }
        showSEG(num);
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291152101.webp" />

### 矩阵键盘

```c
#include <reg52.h>

sbit L0 = P1 ^ 0;
sbit L1 = P1 ^ 1;
sbit L2 = P1 ^ 2;
sbit L3 = P1 ^ 3;

void delay(unsigned int t)
{
    while (t--);
}

int seg[16] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e};
int btn[4]  = {0xef, 0xdf, 0xbf, 0x7f};

void showSEG(int num)
{
    int i;
    for (i = 0; i < 2; i++) {
        P2 = 1 << i;
        if (i == 0) {
            P0 = seg[num / 10];
        } else if (i == 1) {
            P0 = seg[num % 10];
        }
        delay(500);
        P0 = 0xff;
    }
}
void main(void)
{
    int num = 0;
    int i, j;
    while (1) {
        for (i = 0; i < 4; i++) {
            P1 = btn[i];
            for (j = 0; j < 4; j++) {
                if (L0 == 0) num = i * 4 + 1;
                if (L1 == 0) num = i * 4 + 2;
                if (L2 == 0) num = i * 4 + 3;
                if (L3 == 0) num = i * 4 + 4;
            }
            showSEG(num);
            delay(500);
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291624029.webp" />

## 中断

::: details 中断的一些知识点

| 符号 | 描述                      | 说明                                                         | 具体描述         |
| ---- | ------------------------- | ------------------------------------------------------------ | ---------------- |
| EA   | 中断总开关                | 为 `1` 时 CPU `开放` 中断，为 `0` 时 CPU `屏蔽` 所有中断申请 |
| EX0  | 外部中断                  | 为 `1` 时 `允许` 外部中断，为 `0` 时 `禁止` 外部中断         | 见下方 **`EX0`** |
| IT0  | 外部中断 0 触发方式选择位 | 为 `1` 时下降沿触发，为 `0` 时低电平触发                     |

**`EX0`**

-   (此处为外部中断 0，还有其余的中断例如 `EX1`, `ET0`, `ET1`, `ES`) (`ET0`/`ET1`): 定时器中断 (`ES`): 串口中断

**`interrupt 0`**

-   这里不是 C 基础语法，属于嵌入式的语法，用于处理中断 0，当中断 0 触发时，执行的函数

所以触发中断只需给对应的寄存器赋值，例如

```c
EA = 1;
EX0 = 1;
IT0 = 1;
```

执行完成后，会触发 `interrupt 0` 声明的函数，即 `abc`

```c
void abc() interrupt 0 {

}
```

:::

### 中断实现按键点灯

```c
#include <reg52.h>

sbit LED = P0 ^ 0;
sbit KEY = P3 ^ 2;

void it0_init()
{
    EA  = 1; // 总中断开
    EX0 = 1; // IT0中断开
    IT0 = 1; // TCON中控制INT0触发方式位，INT0下降沿触发中断
}

void it0_isr() interrupt 0
{
    if (KEY == 0) LED = !LED;
}

void main(void)
{
    it0_init(); // 中断初始化
    while (1);
}

```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202411291053001.webp" />

## 火灾报警器(对温度、光亮等敏感)

## LCD 显示屏

::: details 其中涉及到的一些知识点

[更多信息](https://blog.csdn.net/m0_73964304/article/details/132531136)

| 符号    | 描述             | 说明                                     | 具体描述          |
| ------- | ---------------- | ---------------------------------------- | ----------------- |
| VSS     | 电源地           | 接地                                     |
| VDD     | 电源正极         | 接电源正极                               |
| VEE/VL  | 液晶显示偏压信号 | 接地，也可以接一个滑动变阻器来控制亮度   |
| RS      | 数据/命令选择    | 为 `1` 时传 `数据`，为 `0` 时传 `命令`   | 见下方 **`RS`**   |
| RW      | 读/写选择        | 为 `1` 时 `读`，为 `0` 时 `写`           |
| E       | 使能信号         | 为 `0` 时 显示屏工作，为 `1` 时 停止工作 |
| D0 ~ D7 | 数据             | 显示的字符                               | 见下方 **`编码`** |

**`RS`**

-   `RS` 信号决定了当前的操作是 `数据` 传送还是 `命令` 传送，其中传 `数据` 是指显示屏上显示什么字符，传 `命令` 是指在哪显示。

**`编码`**

-   显示字符时，需要将字符转换为对应的二进制数，然后通过 `D0` 到 `D7` 输出。字模编码见下图，低四位为横坐标，高四位为纵坐标。

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031132805.webp" />

**`指令表`**

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031351225.webp" />

:::

:::tip 注意
下面的代码中我们的数据 `Data` 首末尾都有三个空字符，所以在 `LCD_Write_Cmd` 写入 `0x00` 如果去除掉 `Data` 的空格，那么更改为 `0x03` 即可.

为什么要加 `0x80` ?

-   在指令集中，所有的指令都有一位是 `1`，`LCD1602` 就是用他来区分是哪一条指令的，其中 指令 8 就是第七位为 `1`，所以加上 `0x80` 就是在屏幕
    第一行第一个位置显示字符以此类推，即可控制在哪显示。

```c
void main()
{
    unsigned char code Data[] = "   I Love You   "; // "I Love You   "  // [!code focus]

    unsigned char i;

    LCD_Init();

    LCD_Write_Cmd(0x00 + 0x80); // LCD_Write_Cmd(0x03 + 0x80) // [!code focus]
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data[i]);
    }
    while (1);
}
```

:::

### 显示字符

```c
#include <reg52.h>

#define LCD_Data P0

sbit LCD_RS = P2 ^ 0;
sbit LCD_RW = P2 ^ 1;
sbit LCD_E  = P2 ^ 2;

void delay(unsigned int t)
{
    while (t--);
}

void main()
{
    unsigned char code Data[] = "   I Love You   "; // 第一行显示，共十六个字符

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data[i]);
    }
    while (1);
}
```

```c
// 初始化
void LCD_Init()
{
    LCD_Write_Cmd(0x01); // 指令1 ——清屏
    LCD_Write_Cmd(0x06); // 指令3 ——AC加1，画面不动
    LCD_Write_Cmd(0x0c); // 指令4 ——显示开，光标关，闪烁关
    LCD_Write_Cmd(0x38); // 指令6 ——8位数据接口，两行显示，5X7点阵
    LCD_Write_Cmd(0x80); // 指令8 ——从第一行第一列开始显示
}
```

```c
// 写命令
void LCD_Write_Cmd(unsigned char Cmd)
{

    LCD_Check_Busy(); // 判忙

    LCD_RS = 0; // 0 指令
    LCD_RW = 0; // 0 写

    LCD_E    = 0;
    LCD_Data = Cmd; // 送指令
    delay(1000);

    LCD_E = 1; // 拉高
    delay(1000);

    LCD_E = 0;
}
```

```c
// 写数据
void LCD_Write_Data(unsigned char Data)
{

    LCD_Check_Busy(); // 判忙

    LCD_RS = 1; // 1 数据
    LCD_RW = 0; // 0 写

    LCD_E    = 0;
    LCD_Data = Data; // 送数据
    delay(1000);

    LCD_E = 1; // 拉高
    delay(1000);

    LCD_E = 0;
}
```

```c
// 忙检测
void LCD_Check_Busy()
{

    unsigned char temp;

    LCD_Data = 0xff; // 十六进制：1111 1111
    LCD_RS   = 0;    // 0 指令
    LCD_RW   = 1;    // 1 读

    do {
        LCD_E = 1;        // 拉高
        temp  = LCD_Data; // 将 LCD 状态保存在 temp 中，用于判忙
        LCD_E = 0;        // 负跳变使能
    } while (temp & 0x80); // 结果为 1，LCD 忙，继续循环；结果为 0，LCD 不忙，可以进行后面的操作
}
```

因为使用的是 `P0` 口，所以需要右下角的上拉电阻，如果使用别的口，则不需要。

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031209760.webp" />

### 显示两行字符

::: details 扩展方法

```c
/**
 * @brief 设置光标位置
 * @param  Line 行位置，范围：1~2
 * @param  Column 列位置，范围：1~16
 * @retval 无
 */
void LCD_SetCursor(unsigned char Line, unsigned char Column)
{
    if (Line == 1) {
        LCD_Write_Cmd(0x80 | (Column - 1));
    } else if (Line == 2) {
        LCD_Write_Cmd(0x80 | (Column - 1 + 0x40));
    }
}
/**
 * @brief  返回值: X的Y次方
 */
int LCD_Pow(int X, int Y)
{
    unsigned char i;
    int Result = 1;
    for (i = 0; i < Y; i++) {
        Result *= X;
    }
    return Result;
}
/**
 * @brief  在LCD1602指定位置开始显示所给数字
 * @param  Line 起始行位置，范围：1~2
 * @param  Column 起始列位置，范围：1~16
 * @param  Number 要显示的数字，范围：0~65535
 * @param  Length 要显示数字的长度，范围：1~5
 * @retval 无
 */
void LCD_ShowNum(unsigned char Line, unsigned char Column, unsigned int Number, unsigned char Length)
{
    unsigned char i;
    LCD_SetCursor(Line, Column);
    for (i = Length; i > 0; i--) {
        LCD_Write_Data(Number / LCD_Pow(10, i - 1) % 10 + '0');
    }
}
/**
 * @brief  在LCD1602指定位置开始显示所给字符串
 * @param  Line 起始行位置，范围：1~2
 * @param  Column 起始列位置，范围：1~16
 * @param  String 要显示的字符串
 * @retval 无
 */
void LCD_ShowString(unsigned char Line, unsigned char Column, char *String)
{
    unsigned char i;
    LCD_SetCursor(Line, Column);
    for (i = 0; String[i] != '\0'; i++) {
        LCD_Write_Data(String[i]);
    }
}
```

这时候可以这样显示两行字符：

```c
void main()
{
    LCD_Init();
    while (1) {
        LCD_ShowString(1, 1, "   I Love You   ");
        LCD_ShowString(2, 1, "abcdefghigklmnopqRSTuvwxyz"); // 显示时
    }
}
```

:::

```c
void main()
{
    unsigned char code Data_1[] = "   I Love You   "; // 第一行显示
    unsigned char code Data_2[] = "abcdefghABCDEFGH"; // 第二行显示

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data_1[i]);
    }

    LCD_Write_Cmd(0x40 + 0x80); // 第二行第一列地址
    for (i = 0; i < 16; i++) {
        LCD_Write_Data(Data_2[i]);
    }

    while (1);
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412041903124.webp" />

### 画面移动

```c
void main()
{
    unsigned char code Data[] = "abcdefghigklmnopqrstuvwxyz";

    unsigned char i;

    LCD_Init(); // LCD1602 初始化

    LCD_Write_Cmd(0x00 + 0x80); // 第一行第一列地址，0x00 可以省去
    for (i = 0; i < 26; i++) {
        LCD_Write_Data(Data[i]);
    }

    while (1) {
        delay(500000);       // 控制移动速度
        LCD_Write_Cmd(0x18); // 指令5 ——画面左移一个字符位，光标不动
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412031403470.webp" />

## OLED 显示屏

## DS1302 时钟

::: details 其中涉及到的一些知识点

| 符号   | 描述          | 说明                                 | 具体描述                |
| ------ | ------------- | ------------------------------------ | ----------------------- |
| VCC2   | 主电源        | 接电源正极                           |
| VCC1   | 后备电源      | 接电源正极                           |
| X1/X2  | 振荡源        | 外接 32.768KHz 晶振                  |
| CE/RST | 复位          | 输入信号，在读、写数据期间，必须为高 |                         |
| I/O    | 数据输入/输出 |                                      | 见下方 **`寄存器地址`** |
| SCLK   | 串行时钟输入  |                                      |

**`寄存器地址`**

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412041903753.webp" />
:::

### LCD1602 显示实时时间

下方代码是在 `LCD1602` 基础上添加了 `DS1302` 时钟实时显示，其余代码在 `LCD1602` 基础上没有改动。
[里面的 LCD_ShowString、LCD_ShowString 可以看上面的扩展方法](/blog/嵌入式/C51#显示两行字符)

```c
sbit RST  = P3 ^ 0;
sbit SCLK = P3 ^ 1;
sbit IO   = P3 ^ 2;

unsigned char DS1302_Time[] = {30, 31, 18, 4, 12, 24, 3}; // 秒分时日月年星期几

void main()
{
    LCD_Init(); // LCD1602 初始化
    LCD_ShowString(1, 1, "  -  -  ");
    LCD_ShowString(2, 1, "  :  :  ");
    while (1) {
        read_time();
        LCD_ShowNum(1, 1, DS1302_Time[5], 2); // 显示年
        LCD_ShowNum(1, 4, DS1302_Time[4], 2); // 显示月
        LCD_ShowNum(1, 7, DS1302_Time[3], 2); // 显示日
        LCD_ShowNum(2, 1, DS1302_Time[2], 2); // 显示时
        LCD_ShowNum(2, 4, DS1302_Time[1], 2); // 显示分
        LCD_ShowNum(2, 7, DS1302_Time[0], 2); // 显示秒
    }
}
```

```c
//写数据
void write_ds1302(unsigned char add, unsigned char dat)
{

    unsigned char i;
    RST = 1;                  // 把复位线拿高
    for (i = 0; i < 8; i++) { // 低位在前
        SCLK = 0;             // 时钟线拿低开始写数据
        IO   = add & 0x01;
        add >>= 1; // 把地址右移一位
        SCLK = 1;  // 时钟线拿高
    }
    for (i = 0; i < 8; i++) {
        SCLK = 0; // 时钟线拿低开始写数据
        IO   = dat & 0x01;
        dat >>= 1; // 把数据右移一位
        SCLK = 1;  // 时钟线拿高
    }
    RST  = 0; // 复位线合低
    SCLK = 0;
    IO   = 0;
}
```

```c
//读数据
unsigned char read_ds1302(unsigned char add)
{
    unsigned char value, i;
    RST = 1;                  // 把复位线拿高
    for (i = 0; i < 8; i++) { // 低位在前
        SCLK = 0;             // 时钟线拿低开始写数据
        IO   = add & 0x01;
        add >>= 1; // 把地址右移一位
        SCLK = 1;  // 时钟线拿高
    }
    for (i = 0; i < 8; i++) {
        SCLK = 0; // 时钟线拿低开始读数据
        value >>= 1;
        if (IO == 1)
            value |= 0x80;
        SCLK = 1; // 时钟线拿高
    }
    RST  = 0; // 复位线合低
    SCLK = 0;
    IO   = 0;
    return value; // 返回读出来的数据
}

```

```c
// BCD码转换为数字
// 返回值为十进制数字
unsigned char datadeal(unsigned char num)
{
    return ((num / 16)) * 10 + num % 16;
}
// 数字转换为BCD码
// 返回值为BCD码
unsigned char to_BCD(unsigned char num)
{
    return (((num / 10) << 4) | (num % 10));
}
```

```c
unsigned char code write_add[] = {0x80, 0x82, 0x84, 0x86, 0x88, 0x8c, 0x8a}; // 写地址
unsigned char code read_add[]  = {0x81, 0x83, 0x85, 0x87, 0x89, 0x8d, 0x8b}; // 读地址

// 读取时间
void read_time()
{
    DS1302_Time[0] = datadeal(read_ds1302(read_add[0])); // 读秒
    DS1302_Time[1] = datadeal(read_ds1302(read_add[1])); // 读分
    DS1302_Time[2] = datadeal(read_ds1302(read_add[2])); // 读时
    DS1302_Time[3] = datadeal(read_ds1302(read_add[3])); // 读日
    DS1302_Time[4] = datadeal(read_ds1302(read_add[4])); // 读月
    DS1302_Time[5] = datadeal(read_ds1302(read_add[5])); // 读年
    DS1302_Time[6] = datadeal(read_ds1302(read_add[6])); // 读星期
}

//写入时间
void write_time()
{
    write_ds1302(0x8e, 0x00);                           // 打开写保护
    write_ds1302(write_add[0], to_BCD(DS1302_Time[0])); // 写秒
    write_ds1302(write_add[1], to_BCD(DS1302_Time[1])); // 写分
    write_ds1302(write_add[2], to_BCD(DS1302_Time[2])); // 写时
    write_ds1302(write_add[3], to_BCD(DS1302_Time[3])); // 写日
    write_ds1302(write_add[4], to_BCD(DS1302_Time[4])); // 写月
    write_ds1302(write_add[5], to_BCD(DS1302_Time[5])); // 写年
    write_ds1302(write_add[6], to_BCD(DS1302_Time[6])); // 写星期
    write_ds1302(0x8e, 0x80);                           // 关闭写保护
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412041833533.webp" />

### 数码管 显示实时时间

```c
int seg[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

void main()
{
    int i;
    while (1) {
        read_time();
        for (i = 0; i < 8; i++) {
            P2 = 1 << i;
            if (i == 0) {
                P0 = seg[DS1302_Time[2] / 10];
            } else if (i == 1) {
                P0 = seg[DS1302_Time[2] % 10];
            } else if (i == 3) {
                P0 = seg[DS1302_Time[1] / 10];
            } else if (i == 4) {
                P0 = seg[DS1302_Time[1] % 10];
            } else if (i == 6) {
                P0 = seg[DS1302_Time[0] / 10];
            } else if (i == 7) {
                P0 = seg[DS1302_Time[0] % 10];
            } else {
                P0 = 0xbf;
            }
            delay(500);
            P0 = 0xff; // 消除拖影
        }
    }
}
```

<image src="https://raw.githubusercontent.com/Lazydd/images/main/202412041944021.webp" />

### OLED 显示实时时间

## SG90 舵机

## 直流电机
